<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bloom Spiral - Overview</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR&family=Work+Sans:ital,wght@0,400;0,500;0,600;0,700;1,400&display=swap" rel="stylesheet">
  <style>
    *{box-sizing:border-box;}
    html,body{
      margin:0;
      height:100%;
      font-family:"Noto Sans KR","Work Sans", "Helvetica Neue", Arial, sans-serif;
      color:#fff;
    }
    body{
      background:#111;
      overflow:hidden;
      cursor:pointer;
    }
    .scene{
      position:fixed;
      inset:0;
    }
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }
    .flower-blur{filter:blur(1px);}
    .dim{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.55);
      transition:background 0.6s ease;
    }
    .logo{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      width:calc(100vw - 40px);
      max-width:none;
      height:auto;
      display:block;
      filter:brightness(0) invert(1) drop-shadow(0 10px 24px rgba(0,0,0,0.45));
      transition:transform 0.9s ease, opacity 0.9s ease;
      pointer-events:none;
    }
    .cta{
      position:absolute;
      bottom:44px;
      left:50%;
      transform:translateX(-50%);
      color:#fff;
      font-size:16px;
      font-weight:600;
      font-family:"Work Sans","Noto Sans KR",sans-serif;
      letter-spacing:0.02em;
      text-shadow:0 2px 8px rgba(0,0,0,0.4);
      transition:opacity 0.4s ease;
      animation:ctaBlink 2s ease-in-out infinite;
      pointer-events:none;
    }
    .overview{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-40%);
      text-align:center;
      max-width:720px;
      line-height:1.7;
      opacity:0;
      transition:opacity 0.9s ease 0.2s, transform 0.9s ease 0.2s;
    }
    .overview h2{
      margin:0 0 16px;
      font-size:18px;
      letter-spacing:0.02em;
      font-weight:700;
      font-family:"Work Sans","Noto Sans KR",sans-serif;
    }
    .overview p{
      margin:0 0 12px;
      font-size:15px;
      font-weight:400;
      font-family:"Noto Sans KR","Work Sans",sans-serif;
    }
    .overview p:last-child{margin-bottom:0;}
    .back-btn{
      position:fixed;
      right:20px;
      bottom:20px;
      padding:10px 14px;
      border:1px solid #fff;
      border-radius:999px;
      background:rgba(0,0,0,0.4);
      color:#fff;
      font-weight:700;
      text-decoration:none;
      box-shadow:0 6px 14px rgba(0,0,0,0.35);
      transition:transform 0.2s ease, box-shadow 0.2s ease;
    }
    .back-btn:hover{
      transform:translateY(-2px);
      box-shadow:0 10px 18px rgba(0,0,0,0.45);
    }
    .is-revealed .logo{
      transform:translate(-50%, -120%);
      opacity:0;
    }
    .is-revealed .dim{
      background:rgba(0,0,0,0.65);
    }
    .is-revealed .cta{
      opacity:0;
    }
    .is-revealed .overview{
      opacity:1;
      transform:translate(-50%,-50%);
    }
    @keyframes ctaBlink{
      0%,100%{opacity:1;}
      50%{opacity:0.4;}
    }
    .page-transition{
      position:fixed;
      inset:0;
      background:#000;
      opacity:1;
      pointer-events:auto;
      transition:opacity 0.6s ease;
      z-index:400;
    }
    .is-ready .page-transition{
      opacity:0;
      pointer-events:none;
    }
    .is-leaving .page-transition{
      opacity:1;
      pointer-events:auto;
    }
  </style>
</head>
<body>
  <div class="page-transition" id="pageTransition"></div>
  <div class="scene" id="scene">
    <canvas id="bgCanvas" class="flower-blur"></canvas>
    <div class="dim"></div>
    <img src="OPLOGO.svg" alt="Bloom Spiral" class="logo" />
    <div class="cta">Click to view overview</div>
    <div class="overview" id="overview">
      <h2></h2>
      <div class="overview-lines"></div>
    </div>
  </div>
  <a class="back-btn" href="app.html">Back</a>

  <script>
    (() => {
      const canvas = document.getElementById("bgCanvas");
      const ctx = canvas.getContext("2d");
      const scene = document.getElementById("scene");
      const backBtn = document.querySelector(".back-btn");
      const pageTransition = document.getElementById("pageTransition");
      const overviewBox = document.getElementById("overview");
      const overviewTitle = overviewBox ? overviewBox.querySelector("h2") : null;
      const overviewLines = overviewBox ? overviewBox.querySelector(".overview-lines") : null;

      const slides = [
        {
          title: "프로젝트 개요",
          lines: [
            "본 프로젝트는 자연 환경, 특히 나무의 시각적 아름다움을 극대화하고 동시에",
            "환경 친화적인 가치를 실현하는 장식 패턴 디자인을 개발하는 것을 목표로 한다.",
            "그리고 이 디자인을 잠복소에 입혀 우리가 흔히 보며 지나치는 가로수를",
            "예술 작품으로 변모시키면서 생태계에 이바지하는 디자인 솔루션을 제시한다."
          ]
        },
        {
          title: "기획 의도",
          lines: [
            "\"친환경 디자인\"",
            "나무의 월동준비와 겨울철 해충방제를 위한 잠복소의 패턴을",
            "디자인하여 친환경 디자인의 가치를 실현.",
            "\"시각적 미의 극대화\"",
            "나무를 단순한 배경이 아닌 주목받는 대상으로 전환하여",
            "도시 미관이나 조경 공간의 예술적 가치를 향상."
          ]
        },
        {
          title: "사용된 패턴",
          lines: [
            "자연 구조에서 가져온 원형(만다라) 기반 + 잎·벌레·꽃·나뭇가지의 반복 모듈"
          ]
        },
        {
          title: "패턴작업에 대하여",
          lines: [
            "원본 패턴 이미지: 나무의 잠복소",
            "(잎, 벌레, 가지가 모여 하나의 보호 구조를 이루는 생태적 패턴)에서 영감",
            "잎 → 곡선 기반 기본 모듈",
            "벌레 → 중심선 + 대칭 날개",
            "꽃 → 방사형 도형으로 단순화",
            "나뭇가지 → 곡률을 가진 선 구조",
            "네 요소를 하나의 원형 구조 안에 재배치하여 만다라화"
          ]
        },
        {
          title: "사용된 알고리즘",
          lines: [
            "삼각함수(sin/cos)로 회전 각도를 계산해 원형으로 배치, 레이어 간 구조의 차이를 줘 생태적 리듬 생성",
            "• 서로다른 네 레이어가 겹쳐도 흐트러지지 않는 중심축 정리",
            "• 각 레이어의 회전·수밀도·크기를 실시간 조절 가능하도록 파라미터화",
            "• 브라우저 캔버스 렌더러로 복잡한 도형도 매끄럽게 렌더링"
          ]
        },
        {
          title: "Bloom Spiral 프로젝트",
          lines: [
            "김유빈, 홍주영, 김태환, 김정아",
            "2025/11/17 - 2025/12/9",
            "계원예술대학교 디지털디자인 수업",
            "지도교수 : 권은경교수님"
          ]
        }
      ];

      let slideIdx = 0;

      function renderSlide() {
        if (!overviewTitle || !overviewLines) return;
        const slide = slides[slideIdx % slides.length];
        overviewTitle.textContent = slide.title;
        overviewLines.innerHTML = "";
        slide.lines.forEach(text => {
          const p = document.createElement("p");
          p.textContent = text;
          overviewLines.appendChild(p);
        });
      }

      const COLORS = {
        line: "#325940",
        main: "#D74236",
        accent: "#A3BFAF",
        sub: "#648C72",
        light: "#F2F2F2"
      };

      const PALETTES = [
        { line: "#2E1A47", main: "#7B2CBF", accent: "#C77DFF", sub: "#48BFE3", light: "#E0D4FA" },
        { line: "#2F3E46", main: "#354F52", accent: "#84A98C", sub: "#CAD2C5", light: "#F6FFF6" },
        { line: "#3A2E39", main: "#E3427D", accent: "#F9C74F", sub: "#43AA8B", light: "#F1E9DA" },
        { line: "#3B2C30", main: "#C73E1D", accent: "#FF9F1C", sub: "#F1D302", light: "#F9F7F3" },
        { line: "#1F2A44", main: "#D00000", accent: "#FFBA08", sub: "#3F88C5", light: "#F8F9FA" }
      ];

      const CONFIG = {
        leafCount: 32,
        leafStart: 70,
        bugCount: 8
      };

      function getPalette() {
        return [COLORS.main, COLORS.accent, COLORS.sub, COLORS.light];
      }

      function hexToHsl(hex) {
        let r = 0, g = 0, b = 0;
        if (hex.length === 4) {
          r = "0x" + hex[1] + hex[1];
          g = "0x" + hex[2] + hex[2];
          b = "0x" + hex[3] + hex[3];
        } else if (hex.length === 7) {
          r = "0x" + hex[1] + hex[2];
          g = "0x" + hex[3] + hex[4];
          b = "0x" + hex[5] + hex[6];
        }
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        return { h: h * 360, s: s * 100, l: l * 100 };
      }

      function hslToHex(h, s, l) {
        h /= 360; s /= 100; l /= 100;
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        const toHex = x => {
          const hex = Math.round(x * 255).toString(16);
          return hex.length === 1 ? "0" + hex : hex;
        };
        return "#" + toHex(r) + toHex(g) + toHex(b);
      }

      function jitterHex(hex, deltaH = 8, deltaL = 6) {
        const { h, s, l } = hexToHsl(hex);
        const nh = (h + (Math.random() * 2 - 1) * deltaH + 360) % 360;
        const nl = Math.min(90, Math.max(10, l + (Math.random() * 2 - 1) * deltaL));
        return hslToHex(nh, s, nl);
      }

      function drawLeaf(inner, outer, layers) {
        const PAL = getPalette();
        const middle = (inner + outer) / 2;
        const half   = (outer - inner) / 2;
        const H      = half * 0.7;

        ctx.save();
        ctx.translate(middle, 0);

        for (let j = 0; j < layers; j++) {
          const t = j / (layers - 1 || 1);
          const w = half * (1 - t * 0.55);
          const h = H    * (1 - t * 0.85);

          ctx.beginPath();
          ctx.moveTo(-w, 0);
          ctx.quadraticCurveTo(0, -h, w, 0);
          ctx.quadraticCurveTo(0,  h, -w, 0);

          ctx.fillStyle = PAL[(j + 1) % PAL.length];
          ctx.fill();

          ctx.strokeStyle = COLORS.line;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawLeaves(scale) {
        const count = CONFIG.leafCount;
        const start = CONFIG.leafStart * scale;
        const outer = 190 * scale;

        ctx.save();
        const step = Math.PI * 2 / count;
        for (let i = 0; i < count; i++) {
          ctx.rotate(step);
          drawLeaf(start, outer, 4);
        }
        ctx.restore();
      }

      function drawOuterRing(scale) {
        const count = CONFIG.leafCount;
        const step = Math.PI * 2 / count;

        ctx.save();

        ctx.beginPath();
        ctx.arc(0, 0, 200 * scale, 0, Math.PI * 2);
        ctx.strokeStyle = COLORS.line;
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = COLORS.sub;

        const arcs = [
          [210, 0, 20, -10, 120],
          [220, 20, 20, 180, 300],
          [180, 60, 10, 250, 30],
          [186, 55, 10, 70, 230]
        ];

        for (let i = 0; i < count; i++) {
          ctx.rotate(step);
          arcs.forEach(([x, y, r, s, e]) => {
            ctx.beginPath();
            ctx.arc(x * scale, y * scale, r * scale, s * Math.PI / 180, e * Math.PI / 180);
            ctx.fill();
            ctx.strokeStyle = COLORS.line;
            ctx.stroke();
          });
        }

        ctx.restore();
      }

      function drawCenterFlower(scale) {
        const leafNum = CONFIG.leafCount;
        const PAL = getPalette();

        const C = Math.max(4, Math.round(leafNum / 4));
        const TOTAL = Math.max(8, Math.round(leafNum / 2));
        const localS = 0.45 + (Math.min(leafNum, 64) / 64) * 0.25;

        ctx.save();
        ctx.scale(scale * localS, scale * localS);

        ctx.strokeStyle = COLORS.line;
        ctx.lineWidth = 1 / (scale * localS);

        for (let i = 0; i < C; i++) {
          ctx.save();
          ctx.rotate((Math.PI * 2 / C) * i);

          ctx.beginPath();
          ctx.arc(10, 0, 10, 0, Math.PI * 2);
          ctx.fillStyle = PAL[i % PAL.length];
          ctx.fill();
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(24, 0, 12, 0, Math.PI * 2);
          ctx.fillStyle = PAL[(i + 1) % PAL.length];
          ctx.fill();
          ctx.stroke();

          ctx.restore();
        }

        for (let i = 0; i < TOTAL; i++) {
          ctx.save();
          ctx.rotate((Math.PI * 2 / TOTAL) * i);

          if (i % 2 === 0) {
            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.quadraticCurveTo(50, 30, 60, 60);
            ctx.quadraticCurveTo(30, 50, 30, 30);
            ctx.fillStyle = COLORS.main;
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.quadraticCurveTo(70, 30, 120, 120);
            ctx.quadraticCurveTo(30, 70, 30, 30);
            ctx.fillStyle = COLORS.sub;
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.moveTo(150, 0);
            ctx.quadraticCurveTo(175, -40, 200, 0);
            ctx.quadraticCurveTo(175, 40, 150, 0);
            ctx.fillStyle = COLORS.accent;
            ctx.fill();
            ctx.stroke();
          }

          ctx.restore();
        }

        ctx.restore();
      }

      function drawBug(scale) {
        const s = 0.18 * scale;
        ctx.fillStyle = COLORS.main;
        ctx.strokeStyle = COLORS.line;
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-130 * s, -170 * s, -190 * s, -90 * s, -110 * s, 0);
        ctx.bezierCurveTo(-190 * s, 90 * s, -130 * s, 170 * s, 0, 100 * s);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(130 * s, -170 * s, 190 * s, -90 * s, 110 * s, 0);
        ctx.bezierCurveTo(190 * s, 90 * s, 130 * s, 170 * s, 0, 100 * s);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -90 * s);
        ctx.lineTo(0, 180 * s);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -90 * s);
        ctx.bezierCurveTo(-30 * s, -140 * s, -50 * s, -180 * s, -40 * s, -200 * s);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -90 * s);
        ctx.bezierCurveTo(30 * s, -140 * s, 50 * s, -180 * s, 40 * s, -200 * s);
        ctx.stroke();
      }

      function drawBugsRing(scale) {
        const count = CONFIG.bugCount;
        const step = Math.PI * 2 / count;
        const radius = CONFIG.leafStart * scale + 40 * scale;

        ctx.save();

        for (let i = 0; i < count; i++) {
          ctx.save();
          ctx.rotate(step * i + step / 2);
          ctx.translate(radius, 0);
          ctx.rotate(Math.PI / 2);
          drawBug(scale);
          ctx.restore();
        }
        ctx.restore();
      }

      function drawTopRedPetals(scale) {
        const count = CONFIG.leafCount;
        const step = Math.PI * 2 / count;

        ctx.save();
        for (let i = 0; i < count; i++) {
          ctx.save();
          ctx.rotate(step * i);

          ctx.beginPath();
          ctx.moveTo(0, 90 * scale);
          ctx.quadraticCurveTo(10 * scale, 70 * scale, 0, 50 * scale);
          ctx.quadraticCurveTo(-10 * scale, 70 * scale, 0, 90 * scale);
          ctx.fillStyle = COLORS.main;
          ctx.fill();
          ctx.strokeStyle = COLORS.line;
          ctx.stroke();

          ctx.restore();
        }
        ctx.restore();
      }

      function drawMandala(cx, cy, s) {
        ctx.save();
        ctx.translate(cx, cy);

        drawOuterRing(s);
        drawLeaves(s);
        drawCenterFlower(s);
        drawBugsRing(s);
        drawTopRedPetals(s);

        ctx.restore();
      }

      function drawScene() {
        const ratio = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width  = rect.width * ratio;
        canvas.height = rect.height * ratio;
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

        ctx.clearRect(0, 0, rect.width, rect.height);

        const baseScale = 1;
        const density = 2;
        const palette = PALETTES[Math.floor(Math.random() * PALETTES.length)];
        Object.assign(COLORS, palette);

        const mandalaScale = baseScale * (1.1 - density * 0.15);
        const baseSpacing = 520;
        const spacingX = baseSpacing * mandalaScale;
        const spacingY = spacingX * 0.86;

        const startY = -spacingY;
        const endY   = rect.height + spacingY;

        let row = 0;
        for (let y = startY; y < endY; y += spacingY, row++) {
          const offsetX = (row % 2 === 0) ? 0 : spacingX / 2;
          for (let x = -spacingX + offsetX; x < rect.width + spacingX; x += spacingX) {
            drawMandala(x, y, mandalaScale);
          }
        }
      }

      function init() {
        drawScene();
      }

      window.addEventListener("resize", init);
      init();
      renderSlide();

      if (scene) {
        scene.addEventListener("click", () => {
          const revealed = document.body.classList.contains("is-revealed");
          if (!revealed) {
            document.body.classList.add("is-revealed");
          } else {
            if (slideIdx < slides.length - 1) {
              slideIdx += 1;
              renderSlide();
            } else {
              navigateWithFade("app.html");
            }
          }
        });
      }

      document.body.classList.add("is-ready");
      function navigateWithFade(target){
        if (!pageTransition) { window.location.href = target; return; }
        document.body.classList.add("is-leaving");
        setTimeout(() => { window.location.href = target; }, 550);
      }
      if (backBtn) {
        backBtn.addEventListener("click", (e) => {
          e.preventDefault();
          navigateWithFade(backBtn.href);
        });
      }
    })();
  </script>
</body>
</html>
